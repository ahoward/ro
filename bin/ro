#! /usr/bin/env ruby
# encoding: utf-8

Ro.script do
  help <<~____
    NAME
    ----
      ro
      
    SYNOPSIS
    --------
      * boot an interactive r.e.p.l. over yer ro data
      * build a json api for your ro data
      * run a local dev server for your ro data

    TL;DR;
    ------
      # boot a console for the ro a ./public/ro (the default)
      #
        ~> ro console

      # build a static API into ./public/api/ro (the default)
      #
        ~> ro build

      # keep building that static a.p.i when any file changes
      #
        ~> ro watch

      # run a local http server that re-builds that static a.p.i on change
      #
        ~> ro server

      # show defaults
      #
        ~> ro defaults

      # show env
      #
        ~> ro env

      # show config
      #
        ~> ro config

    ENV
    ---
      - all sub commands can be affect by the following env vars
      - 12 factor ftw

      - RO_ROOT
        - the root directory of your ro data
      - RO_BUILD
        - the build directory for your ro data api
      - RO_URL
        - the url prefix where your ro data will be found on the interwebs
        - you may use a relative or absolute url
        - please make sure this will resolve
      - RO_PAGE_SIZE
        - the built a.p.i.'s page size
      - RO_LOG
        - log on, or log off
      - RO_DEBUG
        - debug or no debug
      - RO_PORT
        - le port to to serve on

      ARGV
      ----
        - for *all* sub commands
        - you may also specifiy RO_ROOT as the 1'st argument
        - you may also specifiy RO_BUILD as the 2'nd argument
        - you may specify env vars in argv as 'RO_XXX=YYY' pairs, for example:
          ~ `ro console RO_ROOT=./public/ro`
            - or
          ~ `ro console ro_root=./public/ro`

      API
        - the a.p.i is trivially simple, examine the output.
        - if you can't figure out how to use it your probably should not.
  ____

  run do
    help!
  end

  run(:console) do
    setup!

    console!
  end

  run(:build) do
    setup!

    build!
  end

  run(:watch) do
    setup!

    watch!
  end

  run(:server) do
    setup!

    server!
  end

  run(:defaults) do
    setup!

    defaults!
  end

  run(:env) do
    setup!

    env!
  end

  run(:config) do
    setup!

    config!
  end

  run(:directory_index) do
    directory_index!
  end

  def setup!
    setup_env!

    parse_argv!

    validate!
  end

  def parse_argv!
    if argv.size > 0
      ro_root = argv[0]
      ENV['RO_ROOT'] = ro_root
    end

    if argv.size > 1
      ro_build = argv[1]
      ENV['RO_BUILD'] = ro_build 
    end
  end

  def setup_env!
    argv.dup.each_with_index do |arg, i|
      key, val = arg.split('=', 2)

      if key && val 
        ENV[key.upcase] = val

        argv.delete_at(i)
      end
    end

    ENV['RO_PORT'] ||= ENV['PORT']
  end

  def validate!
    abort("Ro.root = #{ Ro.config.root.expand } is not a directory") unless test(?d, Ro.config.root)
    abort("Ro.root = #{ Ro.config.root.expand } is empty") unless test(?s, Ro.config.root)
  end

  def console!
    require "#{$libdir}/ro/script/console.rb"

    Ro::Script::Console.run!(script: self)
  end

  def build!
    require "#{$libdir}/ro/script/builder.rb"

    Ro::Script::Builder.run!(script: self)
  end

  def server!
    require "#{$libdir}/ro/script/server.rb"

    Ro::Script::Server.run!(script: self)
  end

  def watch!
    watch(Ro.config.root) { build! }
  end

  def watch(directory, &block)
    require 'ak47'

    def File.exists?(...) # monkey patch for Ak47 ;-/
      File.exist?(...)
    end

    Ak47(watch_dirs: directory) do
      block.call
    end
  end

  def show(hash)
    puts JSON.parse(hash.to_json).to_yaml
  end

  def defaults!
    show Ro.defaults
  end

  def env!
    show Ro.env
  end

  def config!
    show Ro.config
  end

  def directory_index!
    document_root = Ro::Path.for(argv[0] || './public')

    files = document_root.files.sort
    hrefs = files.map{|file| file.relative_to(document_root).relative}
    anchors = hrefs.map{|href| "<a href='./#{ href }' target='_blank'>./#{ href }</a>"}
    lis = anchors.map{|anchor| "<li>#{ anchor }</li>"}

    html = <<-____
      <html>
        <body style='padding:2em;'>
          <br><br>
          <strong>tl;dr;</strong>
          <br><br>
          <em>
          <ul>
            <li>
              this is a demo of a /ro site with a /ro json api
            </li>
            <li>
              if you can't figure how to use the api from your favorite
                client, you are in the wrong place
            </li>
            <li>
              note: the reason for the /ro/ro in some urls is an artifact of
              the way gh-pages hosts websites -
              https://$user.github.io/$repo/... ergo
              https://ahoward.github.io/ro/ro/ is the location for all /ro
              data
            </li>
            <li>
              see <a href="https://github.com/ahoward/ro/">https://github.com/ahoward/ro/</a> for moar deets
            </li>
          </ul>
          </em>
          <br><br>
          <hr><hr>
          <ul>
            #{ lis.join("\n") }
          </ul>
        </body>
      </html>
    ____

    index_html = document_root.join('index.html')

    index_html.binwrite(html)
    puts index_html
  end
end

BEGIN {
  $stdout.sync = true
  $stderr.sync = true

  $script = File.expand_path(__FILE__)
  $bindir = File.dirname($script)
  $root = File.dirname($bindir)
  $libdir = File.join($root, 'lib')

  require "#{$libdir}/ro"
  require "#{$libdir}/ro/script.rb"
}
