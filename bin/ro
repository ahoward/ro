#! /usr/bin/env ruby
Ro.script do
  run do
    console!
  end

  run(:console) do
    console!
  end

  run(:build) do
    setup!

    if @opts.fetch(:watch)
      watch(Ro.config.root) { build! }
    else
      build!
    end
  end

  run(:serve) do
    serve!
  end

  protected

  def console!
    setup!

    require 'irb'

    $GIANT_FUCKING_HACK = IRB.method(:load_modules)

    Kernel.module_eval do
      def ro
        Ro.root
      end
    end

    def IRB.load_modules
      $GIANT_FUCKING_HACK.call

      prompt = "ro[./#{Ro.root.relative_to(Dir.pwd)}]"

      IRB.conf[:PROMPT][:RO] = {
        PROMPT_I: "#{prompt}:%03n:%i> ",
        PROMPT_N: "#{prompt}:%03n:%i> ",
        PROMPT_S: "#{prompt}:%03n:%i%l ",
        PROMPT_C: "#{prompt}:%03n:%i* ",
        RETURN: "=> %s\n"

      }

      IRB.conf[:PROMPT_MODE] = :RO
      IRB.conf[:AUTO_INDENT] = true
    end

    ::IRB.start
  end

  def build!
    setup!

    require "#{$libdir}/ro/script/builder.rb"

    Ro::Script::Builder.run!(script: self)
  end

  def watch(directory, &block)
    require 'ak47'

    def File.exists?(...) # monkey patch for Ak47 ;-/
      File.exist?(...)
    end

    Ak47(watch_dirs: directory) do
      block.call
    end
  end

  def serve!
    setup!

    Ro.config.set(:url, server_url)

    build!

    threads = [watcher!, server!]

    trap('INT') do
      threads.each do |thread|
        thread.kill
      rescue StandardError
        nil
      end
      exit
    end

    sleep
  end

  def server!
    require 'webrick'

    port = @opts.fetch(:port)
    build_directory = Ro.config.build_directory
    document_root = build_directory.dirname

    index_url = File.join(server_url, 'index.json')

    say("ro.server: @ #{index_url}", color: :magenta)

    Thread.new do
      Thread.current.abort_on_exception = true

      server = WEBrick::HTTPServer.new(
        DocumentRoot: document_root,
        Port: port
      )

      ::Kernel.at_exit { server.shutdown }

      server.start
    end
  end

  def server_url
    port = @opts.fetch(:port)
    build_directory = Ro.config.build_directory
    document_root = build_directory.dirname
    path_info = build_directory.relative_to(document_root)
    Ro.normalize_url("http://localhost:#{port}/#{path_info}")
  end

  def watcher!
    Thread.new do
      Thread.current.abort_on_exception = true
      system "RO_URL=#{Ro.config.url} RO_ROOT=#{Ro.config.root} ro build --watch"
    end
  end

  def setup!
    return if defined?(@opts)

    @opts = Map.new

    root = @options[:root]
    Ro.root = root if root

    port = Ro.cast(:int, (@options[:port] || @options[:p] || ENV['PORT'] || Ro.config.port))
    @opts.set(:port, port)

    watch = Ro.cast(:bool, @options[:watch] || @options[:w])
    @opts.set(:watch, watch)
  end
end

BEGIN {
  $stdout.sync = true
  $stderr.sync = true

  $script = File.expand_path(__FILE__)
  $bindir = File.dirname($script)
  $root = File.dirname($bindir)
  $libdir = File.join($root, 'lib')

  Dir.chdir($root)

  require "#{$libdir}/ro"
  require "#{$libdir}/ro/script.rb"
}
