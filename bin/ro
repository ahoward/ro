#! /usr/bin/env ruby
# encoding: utf-8

Ro.script do
  help <<~____
    NAME
    ----
      ro
      
    SYNOPSIS
    --------
      * boot an interactive r.e.p.l. over yer ro data
      * build a json api for your ro data
      * run a local dev server for your ro data

    TL;DR;
    ------
      # boot a console for the ro a ./public/ro (the default)
      #
        ~> ro console

      # build a static API into ./public/api/ro (the default)
      #
        ~> ro build

      # keep building that static a.p.i when any file changes
      #
        ~> ro watch

      # run a local http server that re-builds that static a.p.i on change
      #
        ~> ro server

      # show defaults
      #
        ~> ro defaults

      # show env
      #
        ~> ro env

      # show config
      #
        ~> ro config

    ENV
    ---
      - all sub commands can be affect by the following env vars
      - 12 factor ftw

      - RO_ROOT
        - the root directory of your ro data
      - RO_BUILD
        - the build directory for your ro data api
      - RO_URL
        - the url prefix where your ro data will be found on the interwebs
        - you may use a relative or absolute url
        - please make sure this will resolve
      - RO_PAGE_SIZE
        - the built a.p.i.'s page size
      - RO_LOG
        - log on, or log off
      - RO_DEBUG
        - debug or no debug
      - RO_PORT
        - le port to to serve on

      ARGV
      ----
        - for *all* sub commands
        - you may also specifiy RO_ROOT as the 1'st argument
        - you may also specifiy RO_BUILD as the 2'nd argument
        - you may specify env vars in argv as 'RO_XXX=YYY' pairs, for example:
          ~ `ro console RO_ROOT=./public/ro`
            - or
          ~ `ro console ro_root=./public/ro`

      API
        - the a.p.i is trivially simple, examine the output.
        - if you can't figure out how to use it your probably should not.
  ____

  run do
    help!
  end

  run(:console) do
    setup!

    console!
  end

  run(:build) do
    setup!

    build!
  end

  run(:watch) do
    setup!

    watch!
  end

  run(:server) do
    setup!

    server!
  end

  run(:defaults) do
    setup!

    defaults!
  end

  run(:env) do
    setup!

    env!
  end

  run(:config) do
    setup!

    config!
  end

  def setup!
    setup_env!

    parse_argv!

    validate!
  end

  def parse_argv!
    if argv.size > 0
      ro_root = argv[0]
      ENV['RO_ROOT'] = ro_root
    end

    if argv.size > 1
      ro_build = argv[1]
      ENV['RO_BUILD'] = ro_build 
    end
  end

  def setup_env!
    argv.dup.each_with_index do |arg, i|
      key, val = arg.split('=', 2)

      if key && val 
        ENV[key.upcase] = val

        argv.delete_at(i)
      end
    end

    ENV['RO_PORT'] ||= ENV['PORT']
  end

  def validate!
    abort("Ro.root = #{ Ro.config.root.expand } is not a directory") unless test(?d, Ro.config.root)
    abort("Ro.root = #{ Ro.config.root.expand } is empty") unless test(?s, Ro.config.root)
  end

  def console!
    require "#{$libdir}/ro/script/console.rb"

    Ro::Script::Console.run!(script: self)
  end

  def build!
    require "#{$libdir}/ro/script/builder.rb"

    Ro::Script::Builder.run!(script: self)
  end

  def server!
    require "#{$libdir}/ro/script/server.rb"

    Ro::Script::Server.run!(script: self)
  end

  def watch!
    watch(Ro.config.root) { build! }
  end

  def watch(directory, &block)
    require 'ak47'

    def File.exists?(...) # monkey patch for Ak47 ;-/
      File.exist?(...)
    end

    Ak47(watch_dirs: directory) do
      block.call
    end
  end

  def show(hash)
    puts JSON.parse(hash.to_json).to_yaml
  end

  def defaults!
    show Ro.defaults
  end

  def env!
    show Ro.env
  end

  def config!
    show Ro.config
  end
end

BEGIN {
  $stdout.sync = true
  $stderr.sync = true

  $script = File.expand_path(__FILE__)
  $bindir = File.dirname($script)
  $root = File.dirname($bindir)
  $libdir = File.join($root, 'lib')

  require "#{$libdir}/ro"
  require "#{$libdir}/ro/script.rb"
}
